%macro DESInit(size=1000,nchar=20);
do;
	_entryorder = 1;
	_len = 0;
	_size = &size;
	array _times(&size) _temporary_ ;
	array _entryOrders(&size) _temporary_ ;
	array _kinds(&size) $ &nchar _temporary_;
	array _actives(&size) _temporary_ ;
	drop _entryOrder _size _len;
end;
%mend;
%macro DESReset;
do;
	_len = 0;
	_entryOrder = 1;
end;
%mend;
%macro DESSetItem(index,entryOrder,time,kind,active);
do;
	_times[&index] = &time;
	_entryOrders[&index] = &entryOrder;
	_kinds[&index] = &kind;
	_actives[&index] = &active;
end;
%mend;
%macro DESCopyItem(ito,ifrom);
do;
	_times[&ito] = _times[&ifrom];
	_entryOrders[&ito] = _entryOrders[&ifrom];
	_kinds[&ito] = _kinds[&ifrom];
	_actives[&ito] = _actives[&ifrom];
end;
%mend;
%macro DESSwapElt(elt, index1, index2, suffix=N);
do;
	_temp&suffix = &elt[&index1];
	&elt[&index1]= &elt[&index2];
	&elt[&index2]= _temp&suffix;
	drop _temp&suffix;
end;
%mend;
%macro DESSwapItem(index1, index2);
do;
	%DESSwapElt(_times,&index1,&index2);
	%DESSwapElt(_entryOrders,&index1,&index2);
	%DESSwapElt(_kinds,&index1,&index2,suffix=C);
	%DESSwapElt(_actives,&index1,&index2);
end;
%mend;
%macro DESClear();
	_len = 0;
%mend;
%macro DESEmpty;
	(_len=0)
%mend;
%macro DESCompare(index1, index2);
	(_times[&index1] < _times[&index2] or (_times[&index1] = _times[&index2] and _entryOrders[&index1] < _entryOrders[&index2]))
%mend;
%macro DESSiftdown(index);
do;
	_parent = &index;
	_done = 0;
	do while (_parent*2 <= _len & ^_done);
		_child = _parent*2;
		if (_child+1 <= _len and %DESCompare(_child+1,_child)) then
			_child = _child + 1;
		if %DESCompare(_child,_parent) then do;
			%DESSwapItem(_child,_parent);
			_parent = _child;
		end;
		else _done = 1;
	end;
	drop _done _parent _child;
end;
%mend;
%macro DESSiftup(index);
do;
	_child = &index;
	_done = 0;
	do while(_child>1 and ^_done);
		_parent = floor(_child/2);
		if %DESCompare(_parent,_child) then
			_done = 1;
		else do;
			%DESSwapItem(_child,_parent);
			_tempN = _child;
			_child = _parent;
			_parent = _tempN;
		end;
	end;
	drop _parent _child _done _tempN;
end;
%mend;	
%macro ScheduleAt(time, kind, debug=0);
do;
	if _len >= _size then do;
		put "ERROR: exceeded size of heap. Consider changing size argument to DESInit macro.";
		stop;
	end;
	_len = _len + 1;
	_entryOrder = _entryOrder + 1;
	%DESSetItem(_len, _entryOrder, &time, &kind, 1);
	%DESSiftup(_len);
	%if &debug %then %do; msg = "NOTE: scheduleAt(kind=" || &kind || ")"; put msg; %end;
end;
%mend;
%macro DESPop();
do;
	_len = _len - 1;
	if (_len>0) then do;
		%DESCopyItem(1,_len+1);
		%DESSiftdown(1);
	end;
end;
%mend;
%macro DESCancelKind(kind);
	do i=1 to _len;
		if _kinds[i] = &kind then _actives[i] = 0;
	end;
%mend;
%macro DESRunMany(start=0,setup=1,n=1,id=_id);
do &id=1 to &n;
	%desRun1(start=&start, setup=0);
end;
%mend;
%macro DESRun1(start=0,setup=1,maxit=1000);
	do;
		%DESReset;
		time = &start;
		previousEventTime = &start;
		%init;
		_counter=0; drop _counter;
		do while(_len>0 and _counter<&maxit);
			if _actives[1] then do;
				time = _times[1];
				kind = _kinds[1];
				%handleMessage;
				previousEventTime = time;
				_counter = _counter + 1;
			end;
			%DESPop;
		end;
		drop time previousEventTime kind;
	end;
%mend;

proc fcmp outlib=sasuser.funcs.trial;
function rgompertz(shape, rate);
	u = rand('uniform');
	if ((shape < 0) and (u < exp(rate/shape))) then out=.;
	else out=log(1-shape*log(u)/rate)/shape;
	return(out);
endsub;
function rllogis(shape, scale);
		return(scale * exp(-log(1/rand('uniform') - 1)/shape));
endsub;
function rllogiscure(cure, shape, scale);
	if rand('uniform')<cure then out=.;
	else out = rllogis(shape,scale);
	return(out);
endsub;
function discountPoint(y, time, dr);
	if (dr <= 0 or time=0) then out = y;
	else out = y/((1+dr)**time);
	return(out);
endsub;
function discountInterval(y, start, finish, dr);
	duration = finish - start;
	if (dr<=0 or duration=0) then out=y*duration;
	else out = y/((1+dr)**start)/log(1+dr)*(1 - 1/((1+dr)**duration));
	return(out);
endsub;
run;
options cmplib=sasuser.funcs;



* Main example;
data parameters;
	Observation = 1;
	Lev = 2;
	Lev_5FU = 3;
	RecurrenceFree = 1;
	AdjuvantTreatment = 2;
	Recurrence = 3;
	Death = 4;
	dr_costs = 0.04;
	dr_health = 0.015;
	d_BS_shape = 0.08845719;
	d_BS_rate = 0.008098087;
	array d_RFS_cure[3](0.397233983474699 0.405557830617764 0.57245177440411);
	array d_RFS_shape[3] (1.65402431099951 1.65402431099951 1.65402431099951);
	array d_RFS_scale[3] (1.12846223420542 1.11939525018453 1.31649151798288);
	c_adjuvant_cycle_1 = 5000;
	c_adjuvant_cycle_2 = 10000;
	u_adjuvant = 0.7;
	t_adjuvant_cycle = 3/52.0;
	n_max_adjuvant_cycles = 10;
	p_tox_1 = 0.2;
	p_tox_2 = 0.4;
	c_tox = 2000;
	u_dis_tox = 0.1;
	u_diseasefree = 0.8;
	array d_CSS_shape[3] (1.52146766208046 1.48534146614485 1.4483150121553);
	array d_CSS_scale[3] (1.15749303118087 1.00945645458403 0.811007356583923);
	c_advanced = 40000;
	u_advanced = 0.6;
run;

%macro addPointCost(cost);
		ECosts = ECosts + discountPoint(&cost, time, dr_costs)
%mend;
%macro init;
	call stream(_id); * _id defined by %DESrunMany;
	state = RecurrenceFree;
	AdjuvantCycles = 0;
	Toxicities = 0;
	ECosts = 0;
	EUtilities = 0;
	utility = u_diseasefree;
	cost = 0;
	%scheduleAt(rgompertz(d_BS_shape, d_BS_rate), "toDeath");
	if (arm ^= Observation) then
		%scheduleAt(time, "toAdjuvantTreatment");
	rfs = rllogiscure(d_RFS_cure[arm],
		d_RFS_shape[arm],
		d_RFS_scale[arm]);
	if (rfs ^= .) then
		%scheduleAt(rfs, "toRecurrence");
	%scheduleAt(55, "toEOF");
%mend;
%macro handleMessage;
	ECosts = ECosts + discountInterval(cost, previousEventTime, time, dr_costs);
	EUtilities = EUtilities + discountInterval(utility, previousEventTime, time, dr_health);
	select(kind);
		when ("toRecurrenceFree") do;
			state = RecurrenceFree;
			utility = u_diseasefree;
		end; 
		when ("toAdjuvantTreatment") do;
			state = AdjuvantTreatment;
			AdjuvantCycles = AdjuvantCycles + 1;
			if arm=Lev then prob = p_tox_1; else prob = p_tox_2;
			if prob < rand('uniform') then
				%scheduleAt(time, "toToxicity");
			utility = u_adjuvant;
			if arm=Lev then %addPointCost(c_adjuvant_cycle_1); else %addPointCost(c_adjuvant_cycle_2);
			if AdjuvantCycles < n_max_adjuvant_cycles then do; * do required here due to quoting issues;
				%scheduleAt(time + t_adjuvant_cycle, "toAdjuvantTreatment");
			end;
			else %scheduleAt(time + t_adjuvant_cycle, "toRecurrenceFree");
		end;
		when ("toToxicity") do;
			Toxicities = Toxicities + 1;
			%addPointCost(c_tox);
			utility = u_adjuvant - u_dis_tox;
		end;
		when ("toRecurrence") do;
			state = Recurrence;
			%DEScancelKind("toAdjuvantTreatment");
			%DEScancelKind("toRecurrenceFree");
			* %DEScancelKind("toDeath");
			utility = u_advanced;
			%addPointCost(c_advanced);
			css = rllogis(d_CSS_shape[arm], d_CSS_scale[arm]);
			%scheduleAt(time + css, "toDeath")
		end;
		when ("toDeath", "toEOF") do;
			%DESclear;
			keep arm _id ECosts EUtilities;
			output;
		end;
		otherwise do;
			msg = "WARNING: kind not matched..." || kind;
			put msg;
			stop;
		end;
	end;
%mend;

option nomprint;
data test;
	set parameters;
	array d_RFS_cure[3] ;
	array d_RFS_shape[3];
	array d_RFS_scale[3];
	array d_CSS_shape[3];
	array d_CSS_scale[3];
	%DESinit;
	arm = Observation;
	call streaminit('PCG', 12345);
	%DESrunMany(n=5e4);
	arm = Lev;
	call streaminit('PCG', 12345);
	%DESrunMany(n=5e4);
	arm = Lev_5FU;
	call streaminit('PCG', 12345);
	%DESrunMany(n=5e4);
run;
proc sql;
select arm, avg(ECosts), avg(EUtilities) from test group by arm;
quit;


%macro ignore;

%macro init;
	%scheduleAt(3, "Clear drains");
	%scheduleAt(4, "Feed cat");
	%scheduleAt(5, "Make tea");
	%scheduleAt(1, "Solve RC tasks");
	%scheduleAt(2, "Tax return");
%mend;
%macro handleMessage;
	put previousEventTime time kind;
%mend;
option nomprint;
data _null_;
	%DESinit;
	%DESrunMany(n=2);
run;

data _null_;
a=discountPoint(10,5,0.03);
b=discountInterval(10,5,10,0.03);
put _all_;
run;

data temp;
	do i=1 to 1e3;
		a=rgompertz(3,3);
		b=rllogis(3,3);
		c=rllogiscure(0.5,3,3);
		output;
	end;
proc means;
run;
%mend;
